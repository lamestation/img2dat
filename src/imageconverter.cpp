#include "imageconverter.h"

#include <QPainter>
#include <QTextStream>
#include <QCoreApplication>
#include <QLabel>

ImageConverter::ImageConverter(QImage image,
        QString filename,
        int framewidth,
        int frameheight,
        int range)
{
    setTransparentColor(QColor(255, 0, 255));

    _image = image;
    _filename = filename;
    this->framewidth = framewidth;
    this->frameheight = frameheight;

    detectDynamicRange(range);
}

void ImageConverter::setTransparentColor(QColor color)
{
    _transparent = color;
}

QImage ImageConverter::chopIntoFrames()
{
    framecountx = _image.width() / framewidth;
    if (_image.width() % framewidth > 0)
        framecountx++;
    framecounty = _image.height() / frameheight;
    if (_image.height() % frameheight > 0)
        framecounty++;

    newframewidth  = ceilingMultiple(framewidth, 8);
    newframeheight = frameheight;
    newwidth  = ceilingMultiple(_image.width()  * newframewidth  / framewidth,8);
    newheight = ceilingMultiple(_image.height() * newframeheight / frameheight, newframeheight);

    QImage newimage(newwidth, newheight, QImage::Format_RGB32);
    newimage.fill(_transparent);

    QPainter paint(&newimage);

    for (int fy = 0; fy < framecounty; fy++)
    {
        for (int fx = 0; fx < framecountx; fx++)
        {
            paint.drawImage(fx*newframewidth,   fy*newframeheight,
                    _image,
                    fx*framewidth,      fy*frameheight,
                    framewidth,         frameheight);
        }
    }

    return newimage;
}


void ImageConverter::detectDynamicRange(int range)
{
    low = high = QColor(_image.pixel(0, 0)).lightness();

    for (int y = 0; y < _image.height(); y++)
    {
        for (int x = 0; x < _image.width(); x++)
        {
            QColor color(_image.pixel(x, y));
            if (color != _transparent)
            {
                int lightness = color.lightness();
                low = qMin(low, lightness);
                high = qMax(high, lightness);
            }
        }
    }

    mid = (low + high) / 2;
    lowbreak = mid - (mid - low) * range / 100;
    highbreak = mid + (high - mid) * range / 100;
}

int ** ImageConverter::buildDataStructure(QImage image)
{
    int ** imagedata = new int*[image.height()];

    for (int y = 0; y < image.height(); y++)
    {
        imagedata[y] = new int[image.width()];

        for (int x = 0; x < image.width(); x++)
        {
            QColor color = image.pixel(x, y);
            int lightness = color.lightness();
            if (color == _transparent)
            {
                imagedata[y][x] = 2;
            }
            else
            {
                if (lightness >= highbreak)
                    imagedata[y][x] = 1;
                else if (lightness <= lowbreak)
                    imagedata[y][x] = 0;
                else
                    imagedata[y][x] = 3;
            }
        }
    }
    return imagedata;
}


void ImageConverter::preview()
{
    QLabel l;
    l.setPixmap(QPixmap::fromImage(chopIntoFrames()));
    l.show();

    qApp->exec();

}

int ImageConverter::frameboost()
{
    return framewidth * frameheight * 2 / 8;
}

QString ImageConverter::assembleSpinHeader()
{
    QString output;
    QTextStream stream(&output);

    stream  << "' *********************************************************\n"
            << "' " << _filename << "\n"
            << "' generated by img2dat " << qApp->applicationVersion() << "\n"
            << "' *********************************************************\n"
            << "PUB Addr\n"
            << "    return @gfx_data\n\n"
            << "DAT\n\n"
            << "gfx_data\n\n"
            << "word    " << frameboost() << "\n"
            << "word    " << framewidth << ", " << frameheight << "\n";

    return output;
}

QString ImageConverter::exportSpin()
{
    QImage newimage = chopIntoFrames();

    int ** newimagedata = buildDataStructure(newimage);

    QString output;
    QTextStream stream(&output);

    stream << assembleSpinHeader();

    // print data
    unsigned short word = 0;
    for (int fy = 0; fy < framecounty; fy++)
    {
        for (int fx = 0; fx < framecountx; fx++)
        {
            for (int y = 0; y < newframeheight; y++)
            {
                stream << "word    ";
                word = 0;
                for (int x = 0; x < newframewidth; x++)
                {
                    if (x % 8 == 0)
                    {
                        word = 0;
                    }
                    word += (newimagedata[fy*newframeheight+y][fx*newframewidth+x] << ((x % 8)*2));

                    if (x % 8 == 7)
                    {
                        stream << QString("$%1").arg(word,4,16,QChar('0'));
                        if (x < newframewidth-1)
                            stream << ",";
                    }

                }

                stream << " ' ";
                for (int x = 0; x < newframewidth; x++)
                {
                    QString s;
                    switch (newimagedata[fy*newframeheight+y][fx*newframewidth+x])
                    {
                        case 2: s = " ";
                                break;
                        case 1: s = "░";
                                break;
                        case 3: s = "▓";
                                break;
                        case 0: s = "█";
                                break;
                    }
                    stream << s;
                }

                stream << "\n";
            }
            stream << "\n";
        }
    }

    return output;
}


int ImageConverter::ceilingMultiple(int x, int multiple)
{
    if (x % multiple == 0)
        return x;
    else
        return ((x / multiple) + 1) * multiple;
}

